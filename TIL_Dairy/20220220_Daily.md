# 今日の目標

- Active Jobを理解する

# 今日の積み上げ

# Active Jobとは?

ActiveJobとは、ジョブを宣言し、それによって**バックエンドで様々な方法によるキュー操作を実行**するためのフレームワークである。  
ジョブには、請求書発行やメール配信などの処理がジョブになり、これらを分割して並列実行もできる。

ジョブ･･･コンピュータがする仕事の単位(請求書発行やメール送信など)

キュー･･･タスクを登録するための入れ物。待ち行列とも言う。

エンキュー･･･キューの登録

# なぜ、非同期バックエンドが必要なのか?

ActiveJobには**非同期バックエンドなるサードパーティー**のキューイングライブラリが必要である。  
Railsから提供されているActiveJobには、ジョブをメモリに保持するインプロセスのキューキングだけなのでプロセスが切れるとジョブは全て失われる。

# よく採用される非同期バックエンド

上記の問題を解決するために、`Sidekiq`や`sucker_punch`といったライブラリがある。

> sucker_punchは非同期処理をスレッドで実行するため、Railsとプロセスを分ける必要がありません。万が一ジョブの実行中にRailsの再起動をすると、実行中のジョブは強制的に中断され、再起動後のリトライも自動では実行されません。

> 一方、Sidekiqは別プロセスを立てるため、Railsプロセスが終了したとしても、問題がなく、リトライも可能です。ただ、ジョブを永続化するために、RedisといったNoSQLも必要になります。

# ActiveJobを使用せず、Sidekiqを利用する

ActiveJobを使用せず、直接Sidekiqを使用するということの可能。  
しかし、多くのプロジェクトでは、ActiveJob経由して、Sidekiqを利用する。そうすることで非同期処理のライブラリがSidekiqから他のライブラリに変わったとしても、コードの流用ができる。

# 参考

[Active Job の基礎 - Railsガイド](https://railsguides.jp/active_job_basics.html)

[Ruby on RailsのActiveJobとは? - qiita](https://qiita.com/petertakahashi/items/cb9ae73e5ba3020f4a89)

# 反省

重要なメール送信や請求書の発行などの処理の数が多くなるとパフォーマンスが低下する可能性がある。  
また、想定外でサーバーが再起動してしまった場合、多大な問題が起こってくるのでsidekiqなどで非同期処理すべきである。